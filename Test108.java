/*=============================
	■■■ 클래스 고급 ■■■
	  - 상속 (Inheritance)
==============================*/

/*
	※ 생성자와 클래스 상속간의 관계

	하위클래스는 상위 클래스의 멤버를 상속받지만.
	생성자는 상속 대상에서 제외된다.
	그리고 하위 클래스의 생성자가 호출될 때
	자동으로 상위 클래스의 생성자가 호출된다.
	이때 호출되는 상위 클래스의 생성자는
	인수가 없는 생성자가 된다.

	상위 클래스 및 하위 클래스를 설계하는 과정에서
	상위 클래스의 생성자를 정의하지않거나
	인수가 없는 생성자만을 정의한 경우
	명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
	아무런 문제가 발생하지 않지만
	상위 클래스에 인자가 있는 생성자만 존재하는 경우에는
	주의해야 한다.

	예를들어 ... 다음에서...

	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			//super();
		}
	}

	하위 클래스인 B_class의 생성자에서
	명시적으로 A_class의 생성자를 호출하지 않으면
	자동으로 인자없는 생성자를 호출한다.
	하지만 A_class에는 인자가 있는 생성자만 존재하고
	인자가 없는 생성자는 존재하지않기때문에 에러가 발생한다.
	따라서 B_class 생성자의 선두에
	다음처럼 명시적으로 상위 클래스의 생성자 호출 구문을 작성해야한다.
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super(10);
			...
			...
		}
	}

*/

/*
===============================================================================================================
 상위 클래스  |    하위 클래스    | 결과
----------------------------------------------------------------------------------------------------------------
생성자를	  |생성자 정의 안함   | → 가능하다.
정의하지	  |인수가 없는 생성자 | → 가능하다.
않음		  |인수가 있는 생성자 | → 가능하다.
---------------------------------------------------------------------------------------------------------------
인수가 없는   |생성자 정의 안함   | → 가능하다.
생성자만 정의 |인수가 없는 생성자 | → 가능하다.
			  |인수가 있는 생성자 |	→ 가능하다.
--------------------------------------------------------------------------------------------------------------
★			  |					  |
인수가 있는   |생성자 정의 안함   | → 에러발생
생성자만 정의 |인수가 없는 생성자 | → 상위 클래스의 해당 생성자를 호출하지않으면 에러 발생
			  |인수가 있는 생성자 | → 상위 클래스의 해당 생성자를 호출하지않으면 에러 발생
===============================================================================================================
*/

// Rect108클래스와 Circle108클래스의 부모 클래스
class SuperTest108
{
	protected double area;		//protected는 상속을 위한 접근제어지시자라고 봐도 무방...
	private String title;		//private는 상속을 받을 수 없다.

	//부모클래스의 인자 없는 사용자 정의 생성자
	public SuperTest108()
	{
		System.out.println("SuperTest108...인자 없는 생성자");
	}

	// 부모 클래스의 문자열을 인자로 받는 사용자 정의 생성자
	public SuperTest108(String title)
	{
		this.title = title;
		System.out.println("SuperTest108...문자열을 인자로 받는 생성자");
	}

	public void write()
	{
		System.out.println(title + "-" + area);
	}

}

// SuperTest108 클래스를 상속받는 자식 클래스
class Rect108 extends SuperTest108
{
	/* <상속 받은 부분>
	protected double area;		

	public void write()
	{
		System.out.println(title + "-" + area);
	}
	*/

	private int w,h;

	// 자식 클래스의 인자가 없는 사용자 정의 생성자
	public Rect108()
	{
		//super();  --자동으로 부모 생성자 호출
	}

	public void calc(int w, int h)
	{
		this.w = w;
		this.h = h;
		area = (double)this.w * this.h;

		write();	//메소드 오버라이딩 때문에 105번이아니고 142번을 호출
	}

	@Override		//어노테이션(annotation) -metadata - JDK 1.5부터 가능
	public void write()		//물려받은 메소드는 사라진다... 내가 고친 메소드만 존재,,,
	{
		System.out.println("w :" + w + ", h : " + h);
		System.out.println("사각형 - "+ area);
	}

	//※ 메소드오버라이딩
	//	상위 클래스를 상속받은 하위 클래스에서
	//	상위 클래스에 정의된 메소드를 다시 정의하는 것으로(재정의)
	//	객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//	재정의는 반드시 상속관계에 있어야 하며,
	//	메소드의 이름, 린턴 타입, 매개변수의 갯수나 타입이
	//	완전히 일치해야 한다.

}

// SuperTest108 클래스를 상속받는 자식 클래스
class Circle108 extends SuperTest108
{
	/* <상속 받은 부분>
	protected double area;		

	public void write()
	{
		System.out.println(title + "-" + area);
	}
	*/

	// 자식 클래스의 문자열을 인자로 받는 사용자 정의 생성자
	public Circle108(String title)	//★CHECK★
	{	
		//super(); => 자동으로 생성되는 생성자는 매개변수 없는 default 생성자가 호출
		super(title);
	}

	public void calc(int r)
	{
		area = r * r * 3.141592;
		write();	//오버라이딩되지 않았기 때문에 부모의 write()사용
	}
}

// main() 메소드를 포함하고 있는 외부의 다른 클래스
public class Test108
{
	public static void main(String[] args)
	{
		Rect108 ob1 = new Rect108();		//인스턴스 생성 시 생성자 호출
		//--==>> SuperTest108...인자 없는 생성자

		//Circle108 ob2 = new Circle108(); ==> 에러
		// 현재 Circle108 클래스에는
		// 매개변수를 필요로하는 사용자 정의 생성자가 만들어져 있으며
		// 이로 인해 default 생성자가 자동으로 삽입되지 않는 상황.

		Circle108 ob2 = new Circle108("원");
		//--==>> SuperTest108...문자열을 인자로 받는 생성자  //이유 : 174번 때문에
	}
}

